<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LSR Trading Dashboard</title>
<script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
<style>
:root {
  --bg: #0d1117; --card: #161b22; --border: #30363d;
  --text: #e6edf3; --dim: #8b949e; --green: #3fb950; --red: #f85149;
  --blue: #58a6ff; --yellow: #d29922; --orange: #db6d28;
  --font: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
}
* { margin:0; padding:0; box-sizing:border-box; }
body { background:var(--bg); color:var(--text); font-family:var(--font); font-size:13px; padding:12px; }
h2 { font-size:13px; font-weight:600; color:var(--dim); text-transform:uppercase; letter-spacing:1px; margin-bottom:10px; }

.dashboard { display:grid; grid-template-columns:1fr 1fr; gap:12px; max-width:1400px; margin:0 auto; }
.full { grid-column: 1 / -1; }
.card { background:var(--card); border:1px solid var(--border); border-radius:8px; padding:16px; }

/* Header */
.header { display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:12px; }
.header-left { display:flex; align-items:center; gap:16px; }
.header h1 { font-size:18px; font-weight:700; color:var(--blue); }
.badge { padding:3px 10px; border-radius:12px; font-size:11px; font-weight:700; text-transform:uppercase; }
.badge-running { background:rgba(63,185,80,0.15); color:var(--green); }
.badge-offline { background:rgba(248,81,73,0.15); color:var(--red); }
.badge-unknown { background:rgba(139,148,158,0.15); color:var(--dim); }

/* Stats row */
.stats { display:flex; gap:20px; flex-wrap:wrap; }
.stat { text-align:right; }
.stat-label { font-size:10px; color:var(--dim); text-transform:uppercase; letter-spacing:0.5px; }
.stat-val { font-size:20px; font-weight:700; }
.stat-val.pos { color:var(--green); }
.stat-val.neg { color:var(--red); }
.stat-val.dim { color:var(--dim); font-size:11px; }

/* Instrument cards */
.instruments { display:grid; grid-template-columns:repeat(auto-fill, minmax(200px, 1fr)); gap:8px; }
.inst { background:var(--bg); border:1px solid var(--border); border-radius:6px; padding:12px; }
.inst-sym { font-size:16px; font-weight:700; color:var(--blue); margin-bottom:2px; }
.inst-price { font-size:22px; font-weight:700; margin-bottom:8px; letter-spacing:-0.5px; }
.inst-row { display:flex; justify-content:space-between; margin:2px 0; }
.inst-label { color:var(--dim); font-size:11px; }
.inst-val { font-weight:600; }
.pdh { color:var(--green); }
.pdl { color:var(--red); }
.pdc { color:var(--yellow); }

/* Positions */
.pos-row { display:flex; justify-content:space-between; align-items:center; padding:10px 0; border-bottom:1px solid var(--border); }
.pos-row:last-child { border:none; }
.pos-info { display:flex; gap:12px; align-items:center; }
.pos-sym { font-weight:700; font-size:15px; }
.pos-dir { font-size:11px; font-weight:700; padding:2px 8px; border-radius:4px; }
.pos-long { background:rgba(63,185,80,0.15); color:var(--green); }
.pos-short { background:rgba(248,81,73,0.15); color:var(--red); }
.pos-detail { font-size:11px; color:var(--dim); line-height:1.5; }
.pos-pnl { font-size:18px; font-weight:700; text-align:right; }

/* Trade log */
.trade-row { display:flex; justify-content:space-between; align-items:center; padding:8px 0; border-bottom:1px solid var(--border); font-size:12px; }
.trade-row:last-child { border:none; }
.trade-left { display:flex; gap:10px; align-items:center; }
.trade-sym { font-weight:700; width:30px; }
.trade-side { font-size:10px; font-weight:700; padding:1px 6px; border-radius:3px; }
.trade-meta { color:var(--dim); font-size:11px; }
.trade-pnl { font-weight:700; }
.trade-status { font-size:10px; font-weight:600; padding:2px 6px; border-radius:3px; }
.st-open { background:rgba(88,166,255,0.15); color:var(--blue); }
.st-closed { background:rgba(63,185,80,0.1); color:var(--dim); }
.st-pending { background:rgba(210,153,34,0.15); color:var(--yellow); }
.st-cancelled { background:rgba(139,148,158,0.1); color:var(--dim); }

/* Signal feed */
.signal-feed { max-height:260px; overflow-y:auto; font-size:11px; line-height:1.7; }
.sig { padding:2px 4px; border-bottom:1px solid rgba(48,54,61,0.4); }

/* Win/Loss summary bar */
.summary-bar { display:flex; gap:16px; align-items:center; margin-bottom:12px; font-size:12px; }
.summary-stat { display:flex; align-items:center; gap:4px; }
.summary-dot { width:8px; height:8px; border-radius:50%; display:inline-block; }

/* Footer */
.footer { text-align:center; color:var(--dim); font-size:10px; padding:8px; }

::-webkit-scrollbar { width:5px; }
::-webkit-scrollbar-track { background:var(--bg); }
::-webkit-scrollbar-thumb { background:var(--border); border-radius:3px; }

@media (max-width:768px) {
  body { padding:6px; font-size:12px; }
  .dashboard { grid-template-columns:1fr; gap:8px; }
  .header { flex-direction:column; align-items:flex-start; }
  .stats { gap:8px; width:100%; justify-content:space-between; }
  .stat { text-align:center; flex:1; }
  .stat-val { font-size:16px; }
  .instruments { grid-template-columns:repeat(2, 1fr); gap:6px; }
  .inst { padding:8px; }
  .inst-sym { font-size:14px; }
  .inst-price { font-size:18px; }
  .pos-pnl { font-size:14px; }
  .hide-m { display:none; }
  .chart-wrap { height:300px; }
}

/* Chart */
.chart-wrap { height:450px; position:relative; }
.chart-btns { display:flex; gap:6px; margin-bottom:10px; flex-wrap:wrap; }
.chart-btn { background:var(--bg); border:1px solid var(--border); color:var(--dim); padding:4px 14px;
  border-radius:4px; cursor:pointer; font-family:var(--font); font-size:12px; font-weight:600; }
.chart-btn.active { background:rgba(88,166,255,0.15); color:var(--blue); border-color:var(--blue); }
.chart-btn:hover { border-color:var(--blue); }
.tf-btns { display:flex; gap:4px; margin-left:auto; }
.tf-btn { background:var(--bg); border:1px solid var(--border); color:var(--dim); padding:3px 8px;
  border-radius:3px; cursor:pointer; font-family:var(--font); font-size:10px; }
.tf-btn.active { color:var(--blue); border-color:var(--blue); }
</style>
</head>
<body>

<!-- Header -->
<div class="card full header" style="margin-bottom:12px;">
  <div class="header-left">
    <h1>‚ö° LSR Dashboard</h1>
    <span id="badge" class="badge badge-unknown">‚Äî</span>
  </div>
  <div class="stats">
    <div class="stat"><div class="stat-label">Balance</div><div class="stat-val" id="balance">‚Äî</div></div>
    <div class="stat"><div class="stat-label">Realized</div><div class="stat-val" id="realized">‚Äî</div></div>
    <div class="stat"><div class="stat-label">Unrealized</div><div class="stat-val" id="unrealized">‚Äî</div></div>
    <div class="stat"><div class="stat-label">Positions</div><div class="stat-val" id="posCount">0</div></div>
    <div class="stat"><div class="stat-label">Updated</div><div class="stat-val dim" id="updated">‚Äî</div></div>
  </div>
</div>

<div class="dashboard">
  <!-- Instruments -->
  <div class="card full">
    <h2>üìä Instruments</h2>
    <div class="instruments" id="instruments"><div style="color:var(--dim)">Loading‚Ä¶</div></div>
  </div>

  <!-- Chart -->
  <div class="card full">
    <div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px;">
      <h2 style="margin:0;">üìà Chart</h2>
      <div style="display:flex;gap:6px;align-items:center;flex-wrap:wrap;">
        <div class="chart-btns" id="chart-btns"></div>
        <div class="tf-btns">
          <button class="tf-btn" data-tf="1m">1m</button>
          <button class="tf-btn active" data-tf="5m">5m</button>
          <button class="tf-btn" data-tf="15m">15m</button>
          <button class="tf-btn" data-tf="1h">1h</button>
        </div>
      </div>
    </div>
    <div class="chart-wrap" id="chart-container"></div>
  </div>

  <!-- Positions -->
  <div class="card">
    <h2>üìç Open Positions</h2>
    <div id="positions"><div style="color:var(--dim)">Loading‚Ä¶</div></div>
  </div>

  <!-- Session Trades -->
  <div class="card">
    <h2>üìã Session Trades</h2>
    <div class="summary-bar" id="summary"></div>
    <div id="trades" style="max-height:320px;overflow-y:auto;"><div style="color:var(--dim)">Loading‚Ä¶</div></div>
  </div>

  <!-- Signal Feed -->
  <div class="card full">
    <h2>üì° Activity Feed</h2>
    <div class="signal-feed" id="signals"><div style="color:var(--dim)">Loading‚Ä¶</div></div>
  </div>
</div>

<div class="footer">LSR Trading Dashboard ‚Ä¢ Real-time WS ‚Ä¢ Chart 60s</div>

<script>
const $ = s => document.querySelector(s);
const api = p => fetch(p).then(r => r.json()).catch(() => null);
const fmt = n => n == null ? '‚Äî' : Number(n).toLocaleString('en-US', {minimumFractionDigits:2, maximumFractionDigits:2});
const pnlStr = n => (n >= 0 ? '+$' : '-$') + fmt(Math.abs(n));
const pnlCls = n => n >= 0 ? 'pos' : 'neg';
const pnlColor = n => n >= 0 ? 'var(--green)' : 'var(--red)';
const WS_URL = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/api/ws`;
const realtimeState = {
  status: null,
  account: null,
  positions: [],
  instruments: [],
};
let bridgeSocket = null;
let reconnectTimer = null;
let reconnectAttempts = 0;
let hasConnectedOnce = false;
let activityRefreshTimer = null;

function touchUpdated() {
  $('#updated').textContent = new Date().toLocaleTimeString();
}

function num(v, fallback = undefined) {
  if (v == null || v === '') return fallback;
  const n = Number(v);
  return Number.isFinite(n) ? n : fallback;
}

function normalizeSymbol(v) {
  if (v == null) return '';
  return String(v).trim().toUpperCase();
}

function normalizeAccount(raw) {
  if (!raw || typeof raw !== 'object') return null;
  const normalized = {};
  const balance = num(raw.balance ?? raw.CashValue ?? raw.NetLiquidation);
  const realized = num(raw.realizedPnl);
  const unrealized = num(raw.unrealizedPnl);
  if (balance !== undefined) normalized.balance = balance;
  if (realized !== undefined) normalized.realizedPnl = realized;
  if (unrealized !== undefined) normalized.unrealizedPnl = unrealized;
  return Object.keys(normalized).length ? normalized : null;
}

function normalizePosition(raw) {
  if (!raw || typeof raw !== 'object') return null;
  const symbol = normalizeSymbol(raw.symbol ?? raw.instrument ?? raw.Symbol);
  if (!symbol) return null;
  const normalized = { symbol };
  const direction = raw.direction ?? raw.marketPosition;
  const quantity = num(raw.quantity ?? raw.qty ?? raw.position);
  const avgPrice = num(raw.avgPrice ?? raw.averagePrice ?? raw.entryPrice);
  const unrealizedPnl = num(raw.unrealizedPnl ?? raw.pnl ?? raw.unrealized);
  const state = raw.state ?? raw.status;
  if (direction != null) normalized.direction = direction;
  if (quantity !== undefined) normalized.quantity = quantity;
  if (avgPrice !== undefined) normalized.avgPrice = avgPrice;
  if (unrealizedPnl !== undefined) normalized.unrealizedPnl = unrealizedPnl;
  if ('sl' in raw || 'stopLoss' in raw || 'stopPrice' in raw) {
    const slRaw = raw.sl ?? raw.stopLoss ?? raw.stopPrice;
    normalized.sl = slRaw == null ? null : num(slRaw, null);
  }
  if ('tp' in raw || 'takeProfit' in raw || 'targetPrice' in raw || 'limitPrice' in raw) {
    const tpRaw = raw.tp ?? raw.takeProfit ?? raw.targetPrice ?? raw.limitPrice;
    normalized.tp = tpRaw == null ? null : num(tpRaw, null);
  }
  if (state != null) normalized.state = String(state).toLowerCase();
  return normalized;
}

function normalizeInstrument(raw) {
  if (!raw || typeof raw !== 'object') return null;
  const symbol = normalizeSymbol(raw.symbol ?? raw.instrument ?? raw.Symbol);
  if (!symbol) return null;
  const normalized = { symbol };
  const last = num(raw.last ?? raw.lastPrice ?? raw.price ?? raw.close);
  const bid = num(raw.bid);
  const ask = num(raw.ask);
  const pdh = num(raw.pdh ?? raw.PDH);
  const pdl = num(raw.pdl ?? raw.PDL);
  const pdc = num(raw.pdc ?? raw.PDC);
  const pnl = num(raw.pnl ?? raw.unrealizedPnl ?? raw.positionPnl ?? raw.dailyPnl);
  if (last !== undefined) normalized.last = last;
  if (bid !== undefined) normalized.bid = bid;
  if (ask !== undefined) normalized.ask = ask;
  if (pdh !== undefined) normalized.pdh = pdh;
  if (pdl !== undefined) normalized.pdl = pdl;
  if (pdc !== undefined) normalized.pdc = pdc;
  if (pnl !== undefined) normalized.pnl = pnl;
  return Object.keys(normalized).length > 1 ? normalized : null;
}

function mergeBySymbol(existing, updates) {
  const merged = existing.map(x => ({ ...x }));
  const idx = new Map(merged.map((x, i) => [x.symbol, i]));
  updates.forEach(u => {
    if (!u || !u.symbol) return;
    const i = idx.get(u.symbol);
    if (i == null) {
      idx.set(u.symbol, merged.length);
      merged.push(u);
    } else {
      merged[i] = { ...merged[i], ...u };
    }
  });
  return merged;
}

function renderStatus(st) {
  if (!st) return;
  const b = $('#badge');
  const status = String(st.status || 'unknown').toLowerCase();
  b.textContent = status.toUpperCase();
  b.className = 'badge badge-' + status;
}

function renderAccount(acc) {
  if (!acc) return;
  $('#balance').textContent = '$' + fmt(acc.balance ?? 0);
  const rEl = $('#realized');
  rEl.textContent = pnlStr(acc.realizedPnl ?? 0);
  rEl.className = 'stat-val ' + pnlCls(acc.realizedPnl ?? 0);
  const uEl = $('#unrealized');
  uEl.textContent = pnlStr(acc.unrealizedPnl ?? 0);
  uEl.className = 'stat-val ' + pnlCls(acc.unrealizedPnl ?? 0);
}

function renderPositions(posList) {
  const posDiv = $('#positions');
  $('#posCount').textContent = posList.length;
  if (!posList.length) {
    posDiv.innerHTML = '<div style="color:var(--dim);padding:12px 0;">Flat ‚Äî no open positions</div>';
    return;
  }

  posDiv.innerHTML = posList.map(p => {
    const dir = p.direction || (p.quantity > 0 ? 'Long' : 'Short');
    const dirCls = String(dir).toLowerCase() === 'long' ? 'pos-long' : 'pos-short';
    const pnl = p.unrealizedPnl ?? 0;
    const sl = p.sl != null ? fmt(p.sl) : '‚Äî';
    const tp = p.tp != null ? fmt(p.tp) : '‚Äî';
    return `<div class="pos-row">
      <div class="pos-info">
        <span class="pos-sym">${p.symbol}</span>
        <span class="pos-dir ${dirCls}">${String(dir).toUpperCase()}</span>
        <span class="pos-detail">
          Entry ${fmt(p.avgPrice)}<span class="hide-m"> ¬∑ SL ${sl} ¬∑ TP ${tp}</span>
        </span>
      </div>
      <div class="pos-pnl" style="color:${pnlColor(pnl)}">${pnlStr(pnl)}</div>
    </div>`;
  }).join('');
}

function instrumentCardHtml(i) {
  const price = i.last != null ? fmt(i.last) : '‚Äî';
  let priceColor = 'var(--text)';
  if (i.last != null && i.pdc != null) {
    priceColor = i.last > i.pdc ? 'var(--green)' : i.last < i.pdc ? 'var(--red)' : 'var(--text)';
  }

  let distHtml = '';
  if (i.last != null && i.pdh != null && i.pdl != null && i.last !== 0) {
    const toH = ((i.pdh - i.last) / i.last * 100).toFixed(2);
    const toL = ((i.last - i.pdl) / i.last * 100).toFixed(2);
    distHtml = `<div class="inst-row" style="margin-top:6px;"><span class="inst-label">‚Üë PDH</span><span class="inst-val" style="font-size:11px;color:var(--dim)">${toH}%</span></div>
      <div class="inst-row"><span class="inst-label">‚Üì PDL</span><span class="inst-val" style="font-size:11px;color:var(--dim)">${toL}%</span></div>`;
  }

  const hasPnl = i.pnl != null;
  const pnlText = hasPnl ? pnlStr(i.pnl) : '‚Äî';
  const pnlStyle = hasPnl ? `color:${pnlColor(i.pnl)}` : 'color:var(--dim)';

  return `<div class="inst" data-symbol="${i.symbol}">
    <div class="inst-sym">${i.symbol}</div>
    <div class="inst-price" style="color:${priceColor}">${price}</div>
    <div class="inst-row"><span class="inst-label">P&L</span><span class="inst-val" style="${pnlStyle}">${pnlText}</span></div>
    <div class="inst-row"><span class="inst-label">PDH</span><span class="inst-val pdh">${fmt(i.pdh)}</span></div>
    <div class="inst-row"><span class="inst-label">PDL</span><span class="inst-val pdl">${fmt(i.pdl)}</span></div>
    <div class="inst-row"><span class="inst-label">PDC</span><span class="inst-val pdc">${fmt(i.pdc)}</span></div>
    ${distHtml}
  </div>`;
}

function renderInstruments(instList) {
  const instDiv = $('#instruments');
  if (!instList.length) {
    instDiv.innerHTML = '<div style="color:var(--dim)">No level data</div>';
    return;
  }
  instDiv.innerHTML = instList.map(instrumentCardHtml).join('');
}

function upsertInstrumentCard(inst) {
  const instDiv = $('#instruments');
  if (!instDiv || !inst || !inst.symbol) return;
  if (!instDiv.querySelector('.inst')) instDiv.innerHTML = '';

  const existing = instDiv.querySelector(`.inst[data-symbol="${inst.symbol}"]`);
  const html = instrumentCardHtml(inst);
  if (existing) {
    existing.outerHTML = html;
  } else {
    instDiv.insertAdjacentHTML('beforeend', html);
  }
}

function applyStatus(st) {
  if (!st) return;
  realtimeState.status = st;
  renderStatus(st);
  touchUpdated();
}

function applyAccountUpdate(raw) {
  const normalized = normalizeAccount(raw);
  if (!normalized) return;
  realtimeState.account = { ...(realtimeState.account || {}), ...normalized };
  renderAccount(realtimeState.account);
  touchUpdated();
}

function applyPositionsUpdate(input, { replace = false } = {}) {
  const updates = (Array.isArray(input) ? input : [input])
    .map(normalizePosition)
    .filter(Boolean);
  if (!updates.length && !replace) return;

  if (replace) {
    realtimeState.positions = updates.filter(p => p.quantity !== 0 && p.state !== 'flat');
  } else {
    const map = new Map(realtimeState.positions.map(p => [p.symbol, p]));
    updates.forEach(p => {
      if (p.quantity === 0 || p.state === 'flat' || p.state === 'closed') {
        map.delete(p.symbol);
      } else {
        map.set(p.symbol, { ...(map.get(p.symbol) || {}), ...p });
      }
    });
    realtimeState.positions = Array.from(map.values());
  }
  renderPositions(realtimeState.positions);
  touchUpdated();
}

function applyInstrumentsUpdate(input, { replace = false } = {}) {
  const updates = (Array.isArray(input) ? input : [input])
    .map(normalizeInstrument)
    .filter(Boolean);
  if (!updates.length && !replace) return;

  if (replace) {
    realtimeState.instruments = updates;
    renderInstruments(realtimeState.instruments);
  } else {
    realtimeState.instruments = mergeBySymbol(realtimeState.instruments, updates);
    const bySymbol = new Map(realtimeState.instruments.map(i => [i.symbol, i]));
    updates.forEach(u => {
      const merged = bySymbol.get(u.symbol);
      if (merged) upsertInstrumentCard(merged);
    });
  }
  touchUpdated();
}

async function updatePrices() {
  const [st, acc, posData, lvl] = await Promise.all([
    api('/api/status'),
    api('/api/account'),
    api('/api/positions'),
    api('/api/levels'),
  ]);

  if (st) applyStatus(st);
  if (acc && !acc.error) applyAccountUpdate(acc);
  if (posData && Array.isArray(posData.positions)) applyPositionsUpdate(posData.positions, { replace: true });
  if (lvl && Array.isArray(lvl.instruments)) applyInstrumentsUpdate(lvl.instruments, { replace: true });
}

async function refreshActivity() {
  // --- Trades ---
  const trData = await api('/api/trades');
  const tradesDiv = $('#trades');
  const summaryDiv = $('#summary');
  if (trData && Array.isArray(trData.trades)) {
    const trades = trData.trades;
    const summary = trData.summary ?? {};

    // Summary bar
    if (summary.total > 0 || trades.length > 0) {
      const open = trades.filter(t => t.status === 'open').length;
      const pending = trades.filter(t => t.status === 'pending').length;
      summaryDiv.innerHTML = `
        <span class="summary-stat"><span class="summary-dot" style="background:var(--green)"></span> ${summary.wins || 0}W</span>
        <span class="summary-stat"><span class="summary-dot" style="background:var(--red)"></span> ${summary.losses || 0}L</span>
        ${summary.total ? `<span style="color:var(--dim)">|</span><span style="color:${pnlColor(summary.pnl)};font-weight:700">${pnlStr(summary.pnl)}</span>` : ''}
        ${summary.winRate ? `<span style="color:var(--dim)">${summary.winRate}%</span>` : ''}
        ${open ? `<span style="color:var(--dim)">|</span><span style="color:var(--blue)">${open} open</span>` : ''}
        ${pending ? `<span style="color:var(--yellow)">${pending} pending</span>` : ''}
      `;
    } else {
      summaryDiv.innerHTML = '';
    }

    // Trade list (reverse: newest first)
    if (trades.length > 0) {
      tradesDiv.innerHTML = [...trades].reverse().map(t => {
        const sym = t.symbol || '?';
        const side = t.side || '';
        const sideColor = side === 'BUY' ? 'var(--green)' : side === 'SELL' ? 'var(--red)' : 'var(--dim)';
        const sideBg = side === 'BUY' ? 'rgba(63,185,80,0.15)' : side === 'SELL' ? 'rgba(248,81,73,0.15)' : 'transparent';
        const time = t.time || '';
        const session = t.session || '';

        let statusHtml = '';
        let pnlHtml = '';

        if (t.status === 'open') {
          statusHtml = '<span class="trade-status st-open">OPEN</span>';
          const pnl = t.pnl || 0;
          pnlHtml = `<span class="trade-pnl" style="color:${pnlColor(pnl)}">${pnlStr(pnl)}</span>`;
        } else if (t.status === 'closed') {
          const icon = t.result === 'win' ? '‚úÖ' : '‚ùå';
          statusHtml = `<span class="trade-status st-closed">${icon} ${(t.result||'').toUpperCase()}</span>`;
          pnlHtml = `<span class="trade-pnl" style="color:${pnlColor(t.pnl)}">${pnlStr(t.pnl)} <span style="font-size:10px;color:var(--dim)">${t.r_actual > 0 ? '+' : ''}${(t.r_actual||0).toFixed(1)}R</span></span>`;
        } else if (t.status === 'cancelled') {
          statusHtml = '<span class="trade-status st-cancelled">EXPIRED</span>';
          pnlHtml = '<span style="color:var(--dim)">‚Äî</span>';
        } else if (t.status === 'pending') {
          statusHtml = '<span class="trade-status st-pending">PENDING</span>';
          pnlHtml = '<span style="color:var(--dim)">‚Äî</span>';
        }

        return `<div class="trade-row">
          <div class="trade-left">
            <span class="trade-sym">${sym}</span>
            ${side ? `<span class="trade-side" style="color:${sideColor};background:${sideBg}">${side}</span>` : ''}
            <span class="trade-meta">${fmt(t.price)}${t.rr ? ` ¬∑ ${t.rr}R` : ''}${session ? ` ¬∑ ${session}` : ''}${time ? ` ¬∑ ${time}` : ''}</span>
          </div>
          <div style="display:flex;gap:10px;align-items:center;">
            ${statusHtml}
            ${pnlHtml}
          </div>
        </div>`;
      }).join('');
    } else {
      tradesDiv.innerHTML = '<div style="color:var(--dim);padding:12px 0;">No trades this session</div>';
    }
  }

  // --- Signals ---
  const sig = await api('/api/signals');
  const feed = $('#signals');
  if (sig && Array.isArray(sig.signals)) {
    if (sig.signals.length) {
      feed.innerHTML = sig.signals.map(s => {
        let c = '';
        if (/FILLED|LONG|BUY|‚úÖ/i.test(s)) c = 'color:var(--green)';
        else if (/SL|STOP|EXIT|SHORT|SELL|‚ùå|Cancel/i.test(s)) c = 'color:var(--red)';
        else if (/PLACING|ORDER|LIMIT/i.test(s)) c = 'color:var(--blue)';
        else if (/Startup|levels/i.test(s)) c = 'color:var(--yellow)';
        return `<div class="sig" style="${c}">${s}</div>`;
      }).join('');
      feed.scrollTop = feed.scrollHeight;
    } else {
      feed.innerHTML = '<div style="color:var(--dim)">No signals</div>';
    }
  }
}

function scheduleActivityRefresh(delay = 250) {
  if (activityRefreshTimer) clearTimeout(activityRefreshTimer);
  activityRefreshTimer = setTimeout(() => {
    activityRefreshTimer = null;
    refreshActivity().catch(() => null);
  }, delay);
}

function handleRealtimePayload(payload, parentType = '') {
  if (Array.isArray(payload)) {
    payload.forEach(item => handleRealtimePayload(item, parentType));
    return;
  }
  if (!payload || typeof payload !== 'object') return;

  const type = String(payload.type ?? payload.topic ?? payload.event ?? parentType ?? '').toLowerCase();
  const data = payload.data ?? payload.payload;
  if (data && data !== payload && (typeof data === 'object' || Array.isArray(data))) {
    handleRealtimePayload(data, type);
  }

  if (payload.status && typeof payload.status === 'object') {
    applyStatus(payload.status);
  } else if (type.includes('status') && typeof payload.status === 'string') {
    applyStatus(payload);
  }

  const accountPayload = payload.account ?? payload.accountData ?? payload.Account;
  if (accountPayload) {
    applyAccountUpdate(accountPayload);
  } else if (type.includes('account')) {
    applyAccountUpdate(payload);
  }

  if (Array.isArray(payload.positions)) {
    applyPositionsUpdate(payload.positions, { replace: Boolean(payload.snapshot || payload.full) });
  } else if (payload.position) {
    applyPositionsUpdate(payload.position);
  } else if (type.includes('position')) {
    applyPositionsUpdate(payload);
  }

  if (Array.isArray(payload.instruments)) {
    applyInstrumentsUpdate(payload.instruments, { replace: Boolean(payload.snapshot || payload.full) });
  }
  if (Array.isArray(payload.prices)) {
    applyInstrumentsUpdate(payload.prices, { replace: Boolean(payload.snapshot || payload.full) });
  }
  if (Array.isArray(payload.quotes)) {
    applyInstrumentsUpdate(payload.quotes, { replace: Boolean(payload.snapshot || payload.full) });
  }
  if (payload.instrument) applyInstrumentsUpdate(payload.instrument);
  if (payload.quote) applyInstrumentsUpdate(payload.quote);
  if (payload.price && typeof payload.price === 'object') {
    applyInstrumentsUpdate({ ...payload.price, symbol: payload.symbol ?? payload.instrument ?? payload.price.symbol });
  }

  const hasPriceLikeFields = payload.symbol && (
    payload.last != null ||
    payload.lastPrice != null ||
    payload.price != null ||
    payload.close != null ||
    payload.bid != null ||
    payload.ask != null ||
    payload.pnl != null ||
    payload.unrealizedPnl != null
  );
  if (hasPriceLikeFields) {
    applyInstrumentsUpdate(payload);
    // Update chart current candle with latest price
    const symbol = normalizeSymbol(payload.symbol ?? payload.instrument);
    const price = num(payload.last ?? payload.lastPrice ?? payload.price ?? payload.close);
    if (symbol && price != null) {
      updateCurrentCandle(symbol, price);
    }
  }

  if (payload.levels && Array.isArray(payload.levels.instruments)) {
    applyInstrumentsUpdate(payload.levels.instruments, { replace: true });
  }

  if (
    Array.isArray(payload.orders) ||
    payload.order ||
    type.includes('order') ||
    type.includes('trade') ||
    type.includes('signal')
  ) {
    scheduleActivityRefresh();
  }
}

function handleRealtimeMessage(raw) {
  let parsed = raw;
  if (typeof raw === 'string') {
    try {
      parsed = JSON.parse(raw);
    } catch {
      return;
    }
  }
  handleRealtimePayload(parsed);
}

function scheduleReconnect() {
  if (reconnectTimer) return;
  const delay = Math.min(1000 * (2 ** reconnectAttempts), 15000);
  reconnectAttempts += 1;
  reconnectTimer = setTimeout(() => {
    reconnectTimer = null;
    connectBridgeSocket();
  }, delay);
}

function connectBridgeSocket() {
  if (typeof WebSocket === 'undefined') return;
  if (bridgeSocket && (bridgeSocket.readyState === WebSocket.OPEN || bridgeSocket.readyState === WebSocket.CONNECTING)) {
    return;
  }

  try {
    bridgeSocket = new WebSocket(WS_URL);
  } catch {
    scheduleReconnect();
    return;
  }

  bridgeSocket.onopen = () => {
    reconnectAttempts = 0;
    if (reconnectTimer) {
      clearTimeout(reconnectTimer);
      reconnectTimer = null;
    }
    if (hasConnectedOnce) refresh().catch(() => null);
    hasConnectedOnce = true;
  };

  bridgeSocket.onmessage = ev => {
    handleRealtimeMessage(ev.data);
  };

  bridgeSocket.onerror = () => {
    if (bridgeSocket && bridgeSocket.readyState === WebSocket.OPEN) bridgeSocket.close();
  };

  bridgeSocket.onclose = () => {
    bridgeSocket = null;
    scheduleReconnect();
  };
}

async function refresh() {
  await Promise.all([updatePrices(), refreshActivity()]);
}

refresh();
connectBridgeSocket();

// --- Chart ---
let chart = null;
let candleSeries = null;
let ema20Series = null;
let ema50Series = null;
let ema200Series = null;
let levelLines = [];
let tradeMarkers = [];
let activeSymbol = 'ES';
let activeTf = '5m';
let previousChartKey = null;
let latestChartLoadId = 0;
const SYMBOLS = ['ES', 'NQ', 'CL', 'GC', 'SI'];

function initChart() {
  const container = document.getElementById('chart-container');
  if (!container || typeof LightweightCharts === 'undefined') return;

  chart = LightweightCharts.createChart(container, {
    width: container.clientWidth,
    height: container.clientHeight,
    layout: { background: { color: '#0d1117' }, textColor: '#8b949e', fontSize: 11, fontFamily: "'JetBrains Mono', monospace" },
    grid: { vertLines: { color: '#1c2128' }, horzLines: { color: '#1c2128' } },
    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
    rightPriceScale: { borderColor: '#30363d' },
    timeScale: { borderColor: '#30363d', timeVisible: true, secondsVisible: false },
  });

  candleSeries = chart.addCandlestickSeries({
    upColor: '#3fb950', downColor: '#f85149', borderUpColor: '#3fb950', borderDownColor: '#f85149',
    wickUpColor: '#3fb950', wickDownColor: '#f85149',
  });

  ema20Series = chart.addLineSeries({ color: '#d29922', lineWidth: 1, title: 'EMA 20', priceLineVisible: false });
  ema50Series = chart.addLineSeries({ color: '#58a6ff', lineWidth: 1, title: 'EMA 50', priceLineVisible: false });
  ema200Series = chart.addLineSeries({ color: '#8b949e', lineWidth: 1, title: 'EMA 200', priceLineVisible: false });

  // Resize
  const ro = new ResizeObserver(() => { if (chart) chart.applyOptions({ width: container.clientWidth }); });
  ro.observe(container);

  // Symbol buttons
  const btnDiv = document.getElementById('chart-btns');
  SYMBOLS.forEach(s => {
    const btn = document.createElement('button');
    btn.className = 'chart-btn' + (s === activeSymbol ? ' active' : '');
    btn.textContent = s;
    btn.onclick = () => { activeSymbol = s; updateChartBtns(); loadChart({ forceFit: true }); };
    btnDiv.appendChild(btn);
  });

  // TF buttons
  document.querySelectorAll('.tf-btn').forEach(btn => {
    btn.onclick = () => {
      activeTf = btn.dataset.tf;
      document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      loadChart({ forceFit: true });
    };
  });

  loadChart({ forceFit: true });
}

function updateChartBtns() {
  document.querySelectorAll('.chart-btn').forEach(b => {
    b.classList.toggle('active', b.textContent === activeSymbol);
  });
}

function updateCurrentCandle(symbol, price) {
  if (!chart || !candleSeries || symbol !== activeSymbol) return;
  if (!price || !Number.isFinite(price)) return;

  // Get current candle data
  const data = candleSeries.data();
  if (!data || !data.length) return;

  // Clone the last candle and update it
  const lastCandle = { ...data[data.length - 1] };
  lastCandle.close = price;
  if (price > lastCandle.high) lastCandle.high = price;
  if (price < lastCandle.low) lastCandle.low = price;

  // Update the candle
  candleSeries.update(lastCandle);
}

async function loadChart({ forceFit = false } = {}) {
  if (!chart || !candleSeries) return;

  const chartLoadId = ++latestChartLoadId;
  const symbol = activeSymbol;
  const tf = activeTf;
  const hours = tf === '1h' ? 72 : tf === '15m' ? 48 : 24;
  const data = await api(`/api/candles?symbol=${symbol}&tf=${tf}&hours=${hours}`);
  if (chartLoadId !== latestChartLoadId || symbol !== activeSymbol || tf !== activeTf) return;
  if (!data || !data.candles || !data.candles.length) return;

  candleSeries.setData(data.candles);
  ema20Series.setData(data.ema20 || []);
  ema50Series.setData(data.ema50 || []);
  ema200Series.setData(data.ema200 || []);
  const chartKey = `${symbol}:${tf}`;
  if (forceFit || previousChartKey !== chartKey) {
    chart.timeScale().fitContent();
    previousChartKey = chartKey;
  }

  const [lvl, swingResp, orderResp] = await Promise.all([
    api('/api/levels'),
    api(`/api/swing-points?symbol=${symbol}`),
    api('/api/orders'),
  ]);
  if (chartLoadId !== latestChartLoadId || symbol !== activeSymbol || tf !== activeTf) return;

  // Remove old level lines
  levelLines.forEach(l => candleSeries.removePriceLine(l));
  levelLines = [];

  // Add PDH/PDL/PDC lines
  if (lvl && lvl.instruments) {
    const inst = lvl.instruments.find(i => i.symbol === symbol);
    if (inst) {
      if (inst.pdh) levelLines.push(candleSeries.createPriceLine({ price: inst.pdh, color: '#3fb950', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'PDH' }));
      if (inst.pdl) levelLines.push(candleSeries.createPriceLine({ price: inst.pdl, color: '#f85149', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'PDL' }));
      if (inst.pdc) levelLines.push(candleSeries.createPriceLine({ price: inst.pdc, color: '#d29922', lineWidth: 1, lineStyle: LightweightCharts.LineStyle.Dashed, axisLabelVisible: true, title: 'PDC' }));
    }
  }

  // Add swing point markers (triangles at swing highs/lows)
  const swingMarkers = [];
  if (swingResp && Array.isArray(swingResp.swingPoints)) {
    for (const swingPoint of swingResp.swingPoints) {
      const price = Number(swingPoint.price);
      if (!Number.isFinite(price)) continue;

      const type = String(swingPoint.type || '').toLowerCase();
      if (type !== 'high' && type !== 'low') continue;

      // Calculate time from timestamp (seconds for TradingView)
      const timestampMs = Number(swingPoint.timestamp);
      if (!Number.isFinite(timestampMs) || timestampMs <= 0) continue;
      const swingTime = Math.floor(timestampMs / 1000);

      const timeframe = String(swingPoint.timeframe || '').toUpperCase();
      
      // Different colors for 5m vs 15m swings
      let color;
      if (timeframe === '5M') {
        color = type === 'high' ? '#db6d28' : '#58a6ff';  // 5m: orange high, blue low
      } else {
        color = type === 'high' ? '#f85149' : '#a371f7';  // 15m: red high, purple low
      }
      
      swingMarkers.push({
        time: swingTime,
        position: type === 'high' ? 'aboveBar' : 'belowBar',
        color,
        shape: type === 'high' ? 'arrowDown' : 'arrowUp',
        text: `${timeframe} ${type.toUpperCase()}`,
        size: 1
      });
    }
    
    if (swingMarkers.length > 0) {
      candleSeries.setMarkers(swingMarkers);
    }
  }

  // Add pending working order lines
  if (orderResp && orderResp.orders) {
    const workingOrders = orderResp.orders.filter(o =>
      o &&
      o.symbol === symbol &&
      String(o.state || '').toLowerCase() === 'working'
    );

    for (const order of workingOrders) {
      const orderType = String(order.orderType || '').toLowerCase();
      const orderPrice = Number(order.price ?? order.stopPrice ?? order.limitPrice);
      if (!Number.isFinite(orderPrice)) continue;

      const action = String(order.action || '').toUpperCase();
      let color = '#58a6ff';
      let titlePrefix = String(order.orderType || 'ORDER').toUpperCase();
      if (orderType === 'stopmarket') {
        color = '#f85149';
        titlePrefix = 'SL';
      } else if (orderType === 'limit') {
        color = '#3fb950';
        titlePrefix = 'TP';
      }
      const actionPrefix = action ? `${action} ` : '';

      levelLines.push(candleSeries.createPriceLine({
        price: orderPrice,
        color,
        lineWidth: 1,
        lineStyle: LightweightCharts.LineStyle.Dashed,
        axisLabelVisible: true,
        title: `${titlePrefix} ${actionPrefix}@ ${fmt(orderPrice)}`,
      }));
    }
  }

  // Clear any old markers
  candleSeries.setMarkers([]);

}

// Init chart after DOM ready
if (typeof LightweightCharts !== 'undefined') {
  initChart();
} else {
  window.addEventListener('load', initChart);
}
</script>
</body>
</html>
